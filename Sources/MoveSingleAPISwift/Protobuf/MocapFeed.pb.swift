// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: MocapFeed.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PointTypes: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case xy // = 0
  case yx // = 1
  case xyz // = 2
  case yxz // = 3
  case xydepth // = 4
  case depthOnly // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .xy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .xy
    case 1: self = .yx
    case 2: self = .xyz
    case 3: self = .yxz
    case 4: self = .xydepth
    case 5: self = .depthOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .xy: return 0
    case .yx: return 1
    case .xyz: return 2
    case .yxz: return 3
    case .xydepth: return 4
    case .depthOnly: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PointTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PointTypes] = [
    .xy,
    .yx,
    .xyz,
    .yxz,
    .xydepth,
    .depthOnly,
  ]
}

#endif  // swift(>=4.2)

enum JType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nose // = 0
  case lEye // = 1
  case rEye // = 2
  case lEar // = 3
  case rEar // = 4
  case headTop // = 5
  case headBottom // = 6
  case head // = 7
  case neckBottom // = 8
  case lShoulder // = 9
  case rShoulder // = 10
  case lElbow // = 11
  case rElbow // = 12
  case lWrist // = 13
  case rWrist // = 14
  case lHip // = 15
  case rHip // = 16
  case midHip // = 17
  case lKnee // = 18
  case rKnee // = 19
  case lAnkle // = 20
  case rAnkle // = 21
  case pelvis // = 22
  case spine // = 23
  case lBaseBigToe // = 24
  case rBaseBigToe // = 25
  case lBigToe // = 26
  case rBigToe // = 27
  case lSmallToe // = 28
  case rSmallToe // = 29
  case lHand // = 30
  case rHand // = 31
  case lHeel // = 32
  case rHeel // = 33
  case chest // = 34
  case lHandRoot // = 35
  case lThumb1Cmc // = 36
  case lThumb2Knuckles // = 37
  case lThumb3Ip // = 38
  case lThumb4FingerTip // = 39
  case lIndex1Knuckles // = 40
  case lIndex2Pip // = 41
  case lIndex3Dip // = 42
  case lIndex4FingerTip // = 43
  case lMiddle1Knuckles // = 44
  case lMiddle2Pip // = 45
  case lMiddle3Dip // = 46
  case lMiddle4FingerTip // = 47
  case lRing1Knuckles // = 48
  case lRing2Pip // = 49
  case lRing3Dip // = 50
  case lRing4FingerTip // = 51
  case lPinky1Knuckles // = 52
  case lPinky2Pip // = 53
  case lPinky3Dip // = 54
  case lPinky4FingerTip // = 55
  case rHandRoot // = 56
  case rThumb1Cmc // = 57
  case rThumb2Knuckles // = 58
  case rThumb3Ip // = 59
  case rThumb4FingerTip // = 60
  case rIndex1Knuckles // = 61
  case rIndex2Pip // = 62
  case rIndex3Dip // = 63
  case rIndex4FingerTip // = 64
  case rMiddle1Knuckles // = 65
  case rMiddle2Pip // = 66
  case rMiddle3Dip // = 67
  case rMiddle4FingerTip // = 68
  case rRing1Knuckles // = 69
  case rRing2Pip // = 70
  case rRing3Dip // = 71
  case rRing4FingerTip // = 72
  case rPinky1Knuckles // = 73
  case rPinky2Pip // = 74
  case rPinky3Dip // = 75
  case rPinky4FingerTip // = 76
  case lFrontMarker // = 77
  case lInfrontMarker // = 78
  case lOutfrontMarker // = 79
  case lBackMarker // = 80
  case lInbackMarker // = 81
  case lOutbackMarker // = 82
  case rFrontMarker // = 83
  case rInfrontMarker // = 84
  case rOutfrontMarker // = 85
  case rBackMarker // = 86
  case rInbackMarker // = 87
  case rOutbackMarker // = 88
  case midEye // = 89
  case midShoulder // = 90
  case midEar // = 91
  case marker0 // = 92
  case marker1 // = 93
  case marker2 // = 94
  case marker3 // = 95
  case marker4 // = 96
  case marker5 // = 97
  case marker0Marker1 // = 98
  case marker0Marker2 // = 99
  case marker1Marker2 // = 100
  case spineBend2 // = 101
  case lumbarSpine // = 102
  case thoracicSpine // = 103
  case spineMidHip // = 104
  case spineMidShould // = 105
  case undefined2 // = 1000
  case UNRECOGNIZED(Int)

  init() {
    self = .nose
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nose
    case 1: self = .lEye
    case 2: self = .rEye
    case 3: self = .lEar
    case 4: self = .rEar
    case 5: self = .headTop
    case 6: self = .headBottom
    case 7: self = .head
    case 8: self = .neckBottom
    case 9: self = .lShoulder
    case 10: self = .rShoulder
    case 11: self = .lElbow
    case 12: self = .rElbow
    case 13: self = .lWrist
    case 14: self = .rWrist
    case 15: self = .lHip
    case 16: self = .rHip
    case 17: self = .midHip
    case 18: self = .lKnee
    case 19: self = .rKnee
    case 20: self = .lAnkle
    case 21: self = .rAnkle
    case 22: self = .pelvis
    case 23: self = .spine
    case 24: self = .lBaseBigToe
    case 25: self = .rBaseBigToe
    case 26: self = .lBigToe
    case 27: self = .rBigToe
    case 28: self = .lSmallToe
    case 29: self = .rSmallToe
    case 30: self = .lHand
    case 31: self = .rHand
    case 32: self = .lHeel
    case 33: self = .rHeel
    case 34: self = .chest
    case 35: self = .lHandRoot
    case 36: self = .lThumb1Cmc
    case 37: self = .lThumb2Knuckles
    case 38: self = .lThumb3Ip
    case 39: self = .lThumb4FingerTip
    case 40: self = .lIndex1Knuckles
    case 41: self = .lIndex2Pip
    case 42: self = .lIndex3Dip
    case 43: self = .lIndex4FingerTip
    case 44: self = .lMiddle1Knuckles
    case 45: self = .lMiddle2Pip
    case 46: self = .lMiddle3Dip
    case 47: self = .lMiddle4FingerTip
    case 48: self = .lRing1Knuckles
    case 49: self = .lRing2Pip
    case 50: self = .lRing3Dip
    case 51: self = .lRing4FingerTip
    case 52: self = .lPinky1Knuckles
    case 53: self = .lPinky2Pip
    case 54: self = .lPinky3Dip
    case 55: self = .lPinky4FingerTip
    case 56: self = .rHandRoot
    case 57: self = .rThumb1Cmc
    case 58: self = .rThumb2Knuckles
    case 59: self = .rThumb3Ip
    case 60: self = .rThumb4FingerTip
    case 61: self = .rIndex1Knuckles
    case 62: self = .rIndex2Pip
    case 63: self = .rIndex3Dip
    case 64: self = .rIndex4FingerTip
    case 65: self = .rMiddle1Knuckles
    case 66: self = .rMiddle2Pip
    case 67: self = .rMiddle3Dip
    case 68: self = .rMiddle4FingerTip
    case 69: self = .rRing1Knuckles
    case 70: self = .rRing2Pip
    case 71: self = .rRing3Dip
    case 72: self = .rRing4FingerTip
    case 73: self = .rPinky1Knuckles
    case 74: self = .rPinky2Pip
    case 75: self = .rPinky3Dip
    case 76: self = .rPinky4FingerTip
    case 77: self = .lFrontMarker
    case 78: self = .lInfrontMarker
    case 79: self = .lOutfrontMarker
    case 80: self = .lBackMarker
    case 81: self = .lInbackMarker
    case 82: self = .lOutbackMarker
    case 83: self = .rFrontMarker
    case 84: self = .rInfrontMarker
    case 85: self = .rOutfrontMarker
    case 86: self = .rBackMarker
    case 87: self = .rInbackMarker
    case 88: self = .rOutbackMarker
    case 89: self = .midEye
    case 90: self = .midShoulder
    case 91: self = .midEar
    case 92: self = .marker0
    case 93: self = .marker1
    case 94: self = .marker2
    case 95: self = .marker3
    case 96: self = .marker4
    case 97: self = .marker5
    case 98: self = .marker0Marker1
    case 99: self = .marker0Marker2
    case 100: self = .marker1Marker2
    case 101: self = .spineBend2
    case 102: self = .lumbarSpine
    case 103: self = .thoracicSpine
    case 104: self = .spineMidHip
    case 105: self = .spineMidShould
    case 1000: self = .undefined2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nose: return 0
    case .lEye: return 1
    case .rEye: return 2
    case .lEar: return 3
    case .rEar: return 4
    case .headTop: return 5
    case .headBottom: return 6
    case .head: return 7
    case .neckBottom: return 8
    case .lShoulder: return 9
    case .rShoulder: return 10
    case .lElbow: return 11
    case .rElbow: return 12
    case .lWrist: return 13
    case .rWrist: return 14
    case .lHip: return 15
    case .rHip: return 16
    case .midHip: return 17
    case .lKnee: return 18
    case .rKnee: return 19
    case .lAnkle: return 20
    case .rAnkle: return 21
    case .pelvis: return 22
    case .spine: return 23
    case .lBaseBigToe: return 24
    case .rBaseBigToe: return 25
    case .lBigToe: return 26
    case .rBigToe: return 27
    case .lSmallToe: return 28
    case .rSmallToe: return 29
    case .lHand: return 30
    case .rHand: return 31
    case .lHeel: return 32
    case .rHeel: return 33
    case .chest: return 34
    case .lHandRoot: return 35
    case .lThumb1Cmc: return 36
    case .lThumb2Knuckles: return 37
    case .lThumb3Ip: return 38
    case .lThumb4FingerTip: return 39
    case .lIndex1Knuckles: return 40
    case .lIndex2Pip: return 41
    case .lIndex3Dip: return 42
    case .lIndex4FingerTip: return 43
    case .lMiddle1Knuckles: return 44
    case .lMiddle2Pip: return 45
    case .lMiddle3Dip: return 46
    case .lMiddle4FingerTip: return 47
    case .lRing1Knuckles: return 48
    case .lRing2Pip: return 49
    case .lRing3Dip: return 50
    case .lRing4FingerTip: return 51
    case .lPinky1Knuckles: return 52
    case .lPinky2Pip: return 53
    case .lPinky3Dip: return 54
    case .lPinky4FingerTip: return 55
    case .rHandRoot: return 56
    case .rThumb1Cmc: return 57
    case .rThumb2Knuckles: return 58
    case .rThumb3Ip: return 59
    case .rThumb4FingerTip: return 60
    case .rIndex1Knuckles: return 61
    case .rIndex2Pip: return 62
    case .rIndex3Dip: return 63
    case .rIndex4FingerTip: return 64
    case .rMiddle1Knuckles: return 65
    case .rMiddle2Pip: return 66
    case .rMiddle3Dip: return 67
    case .rMiddle4FingerTip: return 68
    case .rRing1Knuckles: return 69
    case .rRing2Pip: return 70
    case .rRing3Dip: return 71
    case .rRing4FingerTip: return 72
    case .rPinky1Knuckles: return 73
    case .rPinky2Pip: return 74
    case .rPinky3Dip: return 75
    case .rPinky4FingerTip: return 76
    case .lFrontMarker: return 77
    case .lInfrontMarker: return 78
    case .lOutfrontMarker: return 79
    case .lBackMarker: return 80
    case .lInbackMarker: return 81
    case .lOutbackMarker: return 82
    case .rFrontMarker: return 83
    case .rInfrontMarker: return 84
    case .rOutfrontMarker: return 85
    case .rBackMarker: return 86
    case .rInbackMarker: return 87
    case .rOutbackMarker: return 88
    case .midEye: return 89
    case .midShoulder: return 90
    case .midEar: return 91
    case .marker0: return 92
    case .marker1: return 93
    case .marker2: return 94
    case .marker3: return 95
    case .marker4: return 96
    case .marker5: return 97
    case .marker0Marker1: return 98
    case .marker0Marker2: return 99
    case .marker1Marker2: return 100
    case .spineBend2: return 101
    case .lumbarSpine: return 102
    case .thoracicSpine: return 103
    case .spineMidHip: return 104
    case .spineMidShould: return 105
    case .undefined2: return 1000
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension JType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [JType] = [
    .nose,
    .lEye,
    .rEye,
    .lEar,
    .rEar,
    .headTop,
    .headBottom,
    .head,
    .neckBottom,
    .lShoulder,
    .rShoulder,
    .lElbow,
    .rElbow,
    .lWrist,
    .rWrist,
    .lHip,
    .rHip,
    .midHip,
    .lKnee,
    .rKnee,
    .lAnkle,
    .rAnkle,
    .pelvis,
    .spine,
    .lBaseBigToe,
    .rBaseBigToe,
    .lBigToe,
    .rBigToe,
    .lSmallToe,
    .rSmallToe,
    .lHand,
    .rHand,
    .lHeel,
    .rHeel,
    .chest,
    .lHandRoot,
    .lThumb1Cmc,
    .lThumb2Knuckles,
    .lThumb3Ip,
    .lThumb4FingerTip,
    .lIndex1Knuckles,
    .lIndex2Pip,
    .lIndex3Dip,
    .lIndex4FingerTip,
    .lMiddle1Knuckles,
    .lMiddle2Pip,
    .lMiddle3Dip,
    .lMiddle4FingerTip,
    .lRing1Knuckles,
    .lRing2Pip,
    .lRing3Dip,
    .lRing4FingerTip,
    .lPinky1Knuckles,
    .lPinky2Pip,
    .lPinky3Dip,
    .lPinky4FingerTip,
    .rHandRoot,
    .rThumb1Cmc,
    .rThumb2Knuckles,
    .rThumb3Ip,
    .rThumb4FingerTip,
    .rIndex1Knuckles,
    .rIndex2Pip,
    .rIndex3Dip,
    .rIndex4FingerTip,
    .rMiddle1Knuckles,
    .rMiddle2Pip,
    .rMiddle3Dip,
    .rMiddle4FingerTip,
    .rRing1Knuckles,
    .rRing2Pip,
    .rRing3Dip,
    .rRing4FingerTip,
    .rPinky1Knuckles,
    .rPinky2Pip,
    .rPinky3Dip,
    .rPinky4FingerTip,
    .lFrontMarker,
    .lInfrontMarker,
    .lOutfrontMarker,
    .lBackMarker,
    .lInbackMarker,
    .lOutbackMarker,
    .rFrontMarker,
    .rInfrontMarker,
    .rOutfrontMarker,
    .rBackMarker,
    .rInbackMarker,
    .rOutbackMarker,
    .midEye,
    .midShoulder,
    .midEar,
    .marker0,
    .marker1,
    .marker2,
    .marker3,
    .marker4,
    .marker5,
    .marker0Marker1,
    .marker0Marker2,
    .marker1Marker2,
    .spineBend2,
    .lumbarSpine,
    .thoracicSpine,
    .spineMidHip,
    .spineMidShould,
    .undefined2,
  ]
}

#endif  // swift(>=4.2)

enum PoseType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case coco // = 1
  case mpii // = 2
  case openpose17 // = 3
  case openpose25 // = 4
  case posetrack18 // = 5
  case hm36 // = 6
  case moveai2D // = 7
  case moveai3D // = 8
  case moveai3DBone // = 9
  case hm363DBone // = 10
  case hm363DBoneLength // = 11
  case moveaiFeetMarkers // = 12
  case kalman // = 13
  case posetrack17 // = 14
  case undefined // = 15
  case mixamo // = 16
  case openPoseLhand // = 17
  case openPoseRhand // = 18
  case coco29 // = 19
  case coco133 // = 20
  case footPlanar // = 21
  case rigidSingleMarker // = 22
  case rigidTwoMarkers // = 23
  case rigidThreeMarkers // = 24
  case rigidFourMarkers // = 25
  case rigidFiveMarkers // = 26
  case rigidSixMarkers // = 27
  case threeMarkerDist // = 28
  case spineBend // = 29
  case footTrajectory // = 30
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .coco
    case 2: self = .mpii
    case 3: self = .openpose17
    case 4: self = .openpose25
    case 5: self = .posetrack18
    case 6: self = .hm36
    case 7: self = .moveai2D
    case 8: self = .moveai3D
    case 9: self = .moveai3DBone
    case 10: self = .hm363DBone
    case 11: self = .hm363DBoneLength
    case 12: self = .moveaiFeetMarkers
    case 13: self = .kalman
    case 14: self = .posetrack17
    case 15: self = .undefined
    case 16: self = .mixamo
    case 17: self = .openPoseLhand
    case 18: self = .openPoseRhand
    case 19: self = .coco29
    case 20: self = .coco133
    case 21: self = .footPlanar
    case 22: self = .rigidSingleMarker
    case 23: self = .rigidTwoMarkers
    case 24: self = .rigidThreeMarkers
    case 25: self = .rigidFourMarkers
    case 26: self = .rigidFiveMarkers
    case 27: self = .rigidSixMarkers
    case 28: self = .threeMarkerDist
    case 29: self = .spineBend
    case 30: self = .footTrajectory
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .coco: return 1
    case .mpii: return 2
    case .openpose17: return 3
    case .openpose25: return 4
    case .posetrack18: return 5
    case .hm36: return 6
    case .moveai2D: return 7
    case .moveai3D: return 8
    case .moveai3DBone: return 9
    case .hm363DBone: return 10
    case .hm363DBoneLength: return 11
    case .moveaiFeetMarkers: return 12
    case .kalman: return 13
    case .posetrack17: return 14
    case .undefined: return 15
    case .mixamo: return 16
    case .openPoseLhand: return 17
    case .openPoseRhand: return 18
    case .coco29: return 19
    case .coco133: return 20
    case .footPlanar: return 21
    case .rigidSingleMarker: return 22
    case .rigidTwoMarkers: return 23
    case .rigidThreeMarkers: return 24
    case .rigidFourMarkers: return 25
    case .rigidFiveMarkers: return 26
    case .rigidSixMarkers: return 27
    case .threeMarkerDist: return 28
    case .spineBend: return 29
    case .footTrajectory: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PoseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PoseType] = [
    .none,
    .coco,
    .mpii,
    .openpose17,
    .openpose25,
    .posetrack18,
    .hm36,
    .moveai2D,
    .moveai3D,
    .moveai3DBone,
    .hm363DBone,
    .hm363DBoneLength,
    .moveaiFeetMarkers,
    .kalman,
    .posetrack17,
    .undefined,
    .mixamo,
    .openPoseLhand,
    .openPoseRhand,
    .coco29,
    .coco133,
    .footPlanar,
    .rigidSingleMarker,
    .rigidTwoMarkers,
    .rigidThreeMarkers,
    .rigidFourMarkers,
    .rigidFiveMarkers,
    .rigidSixMarkers,
    .threeMarkerDist,
    .spineBend,
    .footTrajectory,
  ]
}

#endif  // swift(>=4.2)

struct Observations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lidars: [DepthSequence] = []

  var poses: [PoseSequence] = []

  var bboxes: [BBoxSequence] = []

  var segmentations: [SegmentationSequence] = []

  var date: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BBoxSequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SegmentationSequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DepthSequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frames: [DepthMap] = []

  var camera: Camera {
    get {return _camera ?? Camera()}
    set {_camera = newValue}
  }
  /// Returns true if `camera` has been explicitly set.
  var hasCamera: Bool {return self._camera != nil}
  /// Clears the value of `camera`. Subsequent reads from it will return its default value.
  mutating func clearCamera() {self._camera = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _camera: Camera?
}

struct DepthMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Int32 = 0

  var height: Int32 = 0

  var map: [DepthMap.row] = []

  var isRowWise: Bool = false

  var frameID: Int32 = 0

  var timestamp: Float = 0

  var unit: DepthMap.Units = .mm

  var scale: Float = 0

  var confidence: [DepthMap.row] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Units: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case mm // = 0
    case cm // = 1
    case meters // = 2
    case voxel // = 3
    case int8 // = 4
    case int16 // = 5
    case int32 // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .mm
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mm
      case 1: self = .cm
      case 2: self = .meters
      case 3: self = .voxel
      case 4: self = .int8
      case 5: self = .int16
      case 6: self = .int32
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .mm: return 0
      case .cm: return 1
      case .meters: return 2
      case .voxel: return 3
      case .int8: return 4
      case .int16: return 5
      case .int32: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct row {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var row: [Float] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension DepthMap.Units: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [DepthMap.Units] = [
    .mm,
    .cm,
    .meters,
    .voxel,
    .int8,
    .int16,
    .int32,
  ]
}

#endif  // swift(>=4.2)

struct Pose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pose: [Keypoint] = []

  var frameID: Int32 = 0

  var timestamp: Float = 0

  var poseType: PoseType = .none

  var id: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PoseSequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frames: [Pose] = []

  var algorithm: PoseType = .none

  var source: String = String()

  var camera: Camera {
    get {return _camera ?? Camera()}
    set {_camera = newValue}
  }
  /// Returns true if `camera` has been explicitly set.
  var hasCamera: Bool {return self._camera != nil}
  /// Clears the value of `camera`. Subsequent reads from it will return its default value.
  mutating func clearCamera() {self._camera = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _camera: Camera?
}

struct Camera {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var intrinsics: Camera.Intrinsics {
    get {return _storage._intrinsics ?? Camera.Intrinsics()}
    set {_uniqueStorage()._intrinsics = newValue}
  }
  /// Returns true if `intrinsics` has been explicitly set.
  var hasIntrinsics: Bool {return _storage._intrinsics != nil}
  /// Clears the value of `intrinsics`. Subsequent reads from it will return its default value.
  mutating func clearIntrinsics() {_uniqueStorage()._intrinsics = nil}

  var extrinsics: CoordinateSystem {
    get {return _storage._extrinsics ?? CoordinateSystem()}
    set {_uniqueStorage()._extrinsics = newValue}
  }
  /// Returns true if `extrinsics` has been explicitly set.
  var hasExtrinsics: Bool {return _storage._extrinsics != nil}
  /// Clears the value of `extrinsics`. Subsequent reads from it will return its default value.
  mutating func clearExtrinsics() {_uniqueStorage()._extrinsics = nil}

  var isVirtual: Bool {
    get {return _storage._isVirtual}
    set {_uniqueStorage()._isVirtual = newValue}
  }

  var odometry: OdometrySequence {
    get {return _storage._odometry ?? OdometrySequence()}
    set {_uniqueStorage()._odometry = newValue}
  }
  /// Returns true if `odometry` has been explicitly set.
  var hasOdometry: Bool {return _storage._odometry != nil}
  /// Clears the value of `odometry`. Subsequent reads from it will return its default value.
  mutating func clearOdometry() {_uniqueStorage()._odometry = nil}

  var type: Camera.Types {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Types: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case rgb // = 0
    case lidar // = 1
    case rgbd // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .rgb
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .rgb
      case 1: self = .lidar
      case 3: self = .rgbd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .rgb: return 0
      case .lidar: return 1
      case .rgbd: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Intrinsics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var resolution: Camera.Intrinsics.Resolution {
      get {return _resolution ?? Camera.Intrinsics.Resolution()}
      set {_resolution = newValue}
    }
    /// Returns true if `resolution` has been explicitly set.
    var hasResolution: Bool {return self._resolution != nil}
    /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
    mutating func clearResolution() {self._resolution = nil}

    var pixelSize: Camera.Intrinsics.Size {
      get {return _pixelSize ?? Camera.Intrinsics.Size()}
      set {_pixelSize = newValue}
    }
    /// Returns true if `pixelSize` has been explicitly set.
    var hasPixelSize: Bool {return self._pixelSize != nil}
    /// Clears the value of `pixelSize`. Subsequent reads from it will return its default value.
    mutating func clearPixelSize() {self._pixelSize = nil}

    var distortion: [Float] = []

    var focalLengthX: Float = 0

    var focalLengthY: Float = 0

    var centerPointX: Float = 0

    var centerPointY: Float = 0

    var skew: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Unit: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case mm // = 0
      case UNRECOGNIZED(Int)

      init() {
        self = .mm
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .mm
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .mm: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    struct Resolution {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var width: Int32 = 0

      var height: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Size {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var width: Float = 0

      var height: Float = 0

      var unit: Camera.Intrinsics.Unit = .mm

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _resolution: Camera.Intrinsics.Resolution?
    fileprivate var _pixelSize: Camera.Intrinsics.Size?
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Camera.Types: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Camera.Types] = [
    .rgb,
    .lidar,
    .rgbd,
  ]
}

extension Camera.Intrinsics.Unit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Camera.Intrinsics.Unit] = [
    .mm,
  ]
}

#endif  // swift(>=4.2)

struct IMU {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accX: Float = 0

  var accY: Float = 0

  var accZ: Float = 0

  var gyrX: Float = 0

  var gyrY: Float = 0

  var gyrZ: Float = 0

  var magX: Float = 0

  var magY: Float = 0

  var magZ: Float = 0

  var grvX: Float = 0

  var grvY: Float = 0

  var grvZ: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct OdometryInstance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Float {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var imu: IMU {
    get {return _storage._imu ?? IMU()}
    set {_uniqueStorage()._imu = newValue}
  }
  /// Returns true if `imu` has been explicitly set.
  var hasImu: Bool {return _storage._imu != nil}
  /// Clears the value of `imu`. Subsequent reads from it will return its default value.
  mutating func clearImu() {_uniqueStorage()._imu = nil}

  var coordinateSystem: CoordinateSystem {
    get {return _storage._coordinateSystem ?? CoordinateSystem()}
    set {_uniqueStorage()._coordinateSystem = newValue}
  }
  /// Returns true if `coordinateSystem` has been explicitly set.
  var hasCoordinateSystem: Bool {return _storage._coordinateSystem != nil}
  /// Clears the value of `coordinateSystem`. Subsequent reads from it will return its default value.
  mutating func clearCoordinateSystem() {_uniqueStorage()._coordinateSystem = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct OdometrySequence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var trajectory: [OdometryInstance] = []

  var source: OdometrySequence.Source = .slam

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Source: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case slam // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .slam
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .slam
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .slam: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension OdometrySequence.Source: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [OdometrySequence.Source] = [
    .slam,
  ]
}

#endif  // swift(>=4.2)

struct CoordinateSystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transform: Transform {
    get {return _transform ?? Transform()}
    set {_transform = newValue}
  }
  /// Returns true if `transform` has been explicitly set.
  var hasTransform: Bool {return self._transform != nil}
  /// Clears the value of `transform`. Subsequent reads from it will return its default value.
  mutating func clearTransform() {self._transform = nil}

  var isOrigin: Bool = false

  var isRightHand: Bool = false

  var upAxis: CoordinateSystem.Axis = .x

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Axis: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case x // = 0
    case y // = 1
    case z // = 2
    case minusX // = 3
    case minusY // = 4
    case minusZ // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .x
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .x
      case 1: self = .y
      case 2: self = .z
      case 3: self = .minusX
      case 4: self = .minusY
      case 5: self = .minusZ
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .x: return 0
      case .y: return 1
      case .z: return 2
      case .minusX: return 3
      case .minusY: return 4
      case .minusZ: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _transform: Transform?
}

#if swift(>=4.2)

extension CoordinateSystem.Axis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CoordinateSystem.Axis] = [
    .x,
    .y,
    .z,
    .minusX,
    .minusY,
    .minusZ,
  ]
}

#endif  // swift(>=4.2)

struct Keypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var joint: JType = .nose

  var point: [Float] = []

  var confidence: Float = 0

  var toJoint: JType = .nose

  var contactConfidence: Float = 0

  var pointType: PointTypes = .xy

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Translation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Float = 0

  var y: Float = 0

  var z: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Orientation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rotationType: Orientation.RotationType = .quaternion

  var rotationValues: [Float] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum RotationType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case quaternion // = 0
    case matrix // = 1
    case eulerXyz // = 2
    case eulerXzy // = 3
    case eulerYxz // = 4
    case eulerYzx // = 5
    case eulerZxy // = 6
    case eulerZyx // = 7
    case eulerXy // = 8
    case eulerYx // = 9
    case eulerXz // = 10
    case eulerZx // = 11
    case eulerYz // = 12
    case eulerZy // = 13
    case eulerX // = 14
    case eulerY // = 15
    case eulerZ // = 16
    case UNRECOGNIZED(Int)

    init() {
      self = .quaternion
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .quaternion
      case 1: self = .matrix
      case 2: self = .eulerXyz
      case 3: self = .eulerXzy
      case 4: self = .eulerYxz
      case 5: self = .eulerYzx
      case 6: self = .eulerZxy
      case 7: self = .eulerZyx
      case 8: self = .eulerXy
      case 9: self = .eulerYx
      case 10: self = .eulerXz
      case 11: self = .eulerZx
      case 12: self = .eulerYz
      case 13: self = .eulerZy
      case 14: self = .eulerX
      case 15: self = .eulerY
      case 16: self = .eulerZ
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .quaternion: return 0
      case .matrix: return 1
      case .eulerXyz: return 2
      case .eulerXzy: return 3
      case .eulerYxz: return 4
      case .eulerYzx: return 5
      case .eulerZxy: return 6
      case .eulerZyx: return 7
      case .eulerXy: return 8
      case .eulerYx: return 9
      case .eulerXz: return 10
      case .eulerZx: return 11
      case .eulerYz: return 12
      case .eulerZy: return 13
      case .eulerX: return 14
      case .eulerY: return 15
      case .eulerZ: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Orientation.RotationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Orientation.RotationType] = [
    .quaternion,
    .matrix,
    .eulerXyz,
    .eulerXzy,
    .eulerYxz,
    .eulerYzx,
    .eulerZxy,
    .eulerZyx,
    .eulerXy,
    .eulerYx,
    .eulerXz,
    .eulerZx,
    .eulerYz,
    .eulerZy,
    .eulerX,
    .eulerY,
    .eulerZ,
  ]
}

#endif  // swift(>=4.2)

struct Transform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var translation: Translation {
    get {return _translation ?? Translation()}
    set {_translation = newValue}
  }
  /// Returns true if `translation` has been explicitly set.
  var hasTranslation: Bool {return self._translation != nil}
  /// Clears the value of `translation`. Subsequent reads from it will return its default value.
  mutating func clearTranslation() {self._translation = nil}

  var orientation: Orientation {
    get {return _orientation ?? Orientation()}
    set {_orientation = newValue}
  }
  /// Returns true if `orientation` has been explicitly set.
  var hasOrientation: Bool {return self._orientation != nil}
  /// Clears the value of `orientation`. Subsequent reads from it will return its default value.
  mutating func clearOrientation() {self._orientation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _translation: Translation?
  fileprivate var _orientation: Orientation?
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PointTypes: @unchecked Sendable {}
extension JType: @unchecked Sendable {}
extension PoseType: @unchecked Sendable {}
extension Observations: @unchecked Sendable {}
extension BBoxSequence: @unchecked Sendable {}
extension SegmentationSequence: @unchecked Sendable {}
extension DepthSequence: @unchecked Sendable {}
extension DepthMap: @unchecked Sendable {}
extension DepthMap.Units: @unchecked Sendable {}
extension DepthMap.row: @unchecked Sendable {}
extension Pose: @unchecked Sendable {}
extension PoseSequence: @unchecked Sendable {}
extension Camera: @unchecked Sendable {}
extension Camera.Types: @unchecked Sendable {}
extension Camera.Intrinsics: @unchecked Sendable {}
extension Camera.Intrinsics.Unit: @unchecked Sendable {}
extension Camera.Intrinsics.Resolution: @unchecked Sendable {}
extension Camera.Intrinsics.Size: @unchecked Sendable {}
extension IMU: @unchecked Sendable {}
extension OdometryInstance: @unchecked Sendable {}
extension OdometrySequence: @unchecked Sendable {}
extension OdometrySequence.Source: @unchecked Sendable {}
extension CoordinateSystem: @unchecked Sendable {}
extension CoordinateSystem.Axis: @unchecked Sendable {}
extension Keypoint: @unchecked Sendable {}
extension Translation: @unchecked Sendable {}
extension Orientation: @unchecked Sendable {}
extension Orientation.RotationType: @unchecked Sendable {}
extension Transform: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PointTypes: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "XY"),
    1: .same(proto: "YX"),
    2: .same(proto: "XYZ"),
    3: .same(proto: "YXZ"),
    4: .same(proto: "XYDepth"),
    5: .same(proto: "DepthOnly"),
  ]
}

extension JType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Nose"),
    1: .same(proto: "L_Eye"),
    2: .same(proto: "R_Eye"),
    3: .same(proto: "L_Ear"),
    4: .same(proto: "R_Ear"),
    5: .same(proto: "Head_Top"),
    6: .same(proto: "Head_Bottom"),
    7: .same(proto: "Head"),
    8: .same(proto: "Neck_Bottom"),
    9: .same(proto: "L_Shoulder"),
    10: .same(proto: "R_Shoulder"),
    11: .same(proto: "L_Elbow"),
    12: .same(proto: "R_Elbow"),
    13: .same(proto: "L_Wrist"),
    14: .same(proto: "R_Wrist"),
    15: .same(proto: "L_Hip"),
    16: .same(proto: "R_Hip"),
    17: .same(proto: "Mid_Hip"),
    18: .same(proto: "L_Knee"),
    19: .same(proto: "R_Knee"),
    20: .same(proto: "L_Ankle"),
    21: .same(proto: "R_Ankle"),
    22: .same(proto: "Pelvis"),
    23: .same(proto: "Spine"),
    24: .same(proto: "L_BaseBigToe"),
    25: .same(proto: "R_BaseBigToe"),
    26: .same(proto: "L_BigToe"),
    27: .same(proto: "R_BigToe"),
    28: .same(proto: "L_SmallToe"),
    29: .same(proto: "R_SmallToe"),
    30: .same(proto: "L_Hand"),
    31: .same(proto: "R_Hand"),
    32: .same(proto: "L_Heel"),
    33: .same(proto: "R_Heel"),
    34: .same(proto: "Chest"),
    35: .same(proto: "L_HandRoot"),
    36: .same(proto: "L_Thumb1CMC"),
    37: .same(proto: "L_Thumb2Knuckles"),
    38: .same(proto: "L_Thumb3IP"),
    39: .same(proto: "L_Thumb4FingerTip"),
    40: .same(proto: "L_Index1Knuckles"),
    41: .same(proto: "L_Index2PIP"),
    42: .same(proto: "L_Index3DIP"),
    43: .same(proto: "L_Index4FingerTip"),
    44: .same(proto: "L_Middle1Knuckles"),
    45: .same(proto: "L_Middle2PIP"),
    46: .same(proto: "L_Middle3DIP"),
    47: .same(proto: "L_Middle4FingerTip"),
    48: .same(proto: "L_Ring1Knuckles"),
    49: .same(proto: "L_Ring2PIP"),
    50: .same(proto: "L_Ring3DIP"),
    51: .same(proto: "L_Ring4FingerTip"),
    52: .same(proto: "L_Pinky1Knuckles"),
    53: .same(proto: "L_Pinky2PIP"),
    54: .same(proto: "L_Pinky3DIP"),
    55: .same(proto: "L_Pinky4FingerTip"),
    56: .same(proto: "R_HandRoot"),
    57: .same(proto: "R_Thumb1CMC"),
    58: .same(proto: "R_Thumb2Knuckles"),
    59: .same(proto: "R_Thumb3IP"),
    60: .same(proto: "R_Thumb4FingerTip"),
    61: .same(proto: "R_Index1Knuckles"),
    62: .same(proto: "R_Index2PIP"),
    63: .same(proto: "R_Index3DIP"),
    64: .same(proto: "R_Index4FingerTip"),
    65: .same(proto: "R_Middle1Knuckles"),
    66: .same(proto: "R_Middle2PIP"),
    67: .same(proto: "R_Middle3DIP"),
    68: .same(proto: "R_Middle4FingerTip"),
    69: .same(proto: "R_Ring1Knuckles"),
    70: .same(proto: "R_Ring2PIP"),
    71: .same(proto: "R_Ring3DIP"),
    72: .same(proto: "R_Ring4FingerTip"),
    73: .same(proto: "R_Pinky1Knuckles"),
    74: .same(proto: "R_Pinky2PIP"),
    75: .same(proto: "R_Pinky3DIP"),
    76: .same(proto: "R_Pinky4FingerTip"),
    77: .same(proto: "L_front_marker"),
    78: .same(proto: "L_infront_marker"),
    79: .same(proto: "L_outfront_marker"),
    80: .same(proto: "L_back_marker"),
    81: .same(proto: "L_inback_marker"),
    82: .same(proto: "L_outback_marker"),
    83: .same(proto: "R_front_marker"),
    84: .same(proto: "R_infront_marker"),
    85: .same(proto: "R_outfront_marker"),
    86: .same(proto: "R_back_marker"),
    87: .same(proto: "R_inback_marker"),
    88: .same(proto: "R_outback_marker"),
    89: .same(proto: "Mid_Eye"),
    90: .same(proto: "Mid_Shoulder"),
    91: .same(proto: "Mid_Ear"),
    92: .same(proto: "marker0"),
    93: .same(proto: "marker1"),
    94: .same(proto: "marker2"),
    95: .same(proto: "marker3"),
    96: .same(proto: "marker4"),
    97: .same(proto: "marker5"),
    98: .same(proto: "marker0_marker1"),
    99: .same(proto: "marker0_marker2"),
    100: .same(proto: "marker1_marker2"),
    101: .same(proto: "SpineBend2"),
    102: .same(proto: "LumbarSpine"),
    103: .same(proto: "ThoracicSpine"),
    104: .same(proto: "SpineMidHip"),
    105: .same(proto: "SpineMidShould"),
    1000: .same(proto: "UNDEFINED2"),
  ]
}

extension PoseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "COCO"),
    2: .same(proto: "MPII"),
    3: .same(proto: "OPENPOSE17"),
    4: .same(proto: "OPENPOSE25"),
    5: .same(proto: "POSETRACK18"),
    6: .same(proto: "HM36"),
    7: .same(proto: "MOVEAI_2D"),
    8: .same(proto: "MOVEAI_3D"),
    9: .same(proto: "MOVEAI_3D_Bone"),
    10: .same(proto: "HM36_3D_Bone"),
    11: .same(proto: "HM36_3D_BoneLength"),
    12: .same(proto: "MOVEAI_FeetMarkers"),
    13: .same(proto: "Kalman"),
    14: .same(proto: "POSETRACK17"),
    15: .same(proto: "UNDEFINED"),
    16: .same(proto: "MIXAMO"),
    17: .same(proto: "OpenPose_LHand"),
    18: .same(proto: "OpenPose_RHand"),
    19: .same(proto: "COCO29"),
    20: .same(proto: "COCO133"),
    21: .same(proto: "FootPlanar"),
    22: .same(proto: "rigid_single_marker"),
    23: .same(proto: "rigid_two_markers"),
    24: .same(proto: "rigid_three_markers"),
    25: .same(proto: "rigid_four_markers"),
    26: .same(proto: "rigid_five_markers"),
    27: .same(proto: "rigid_six_markers"),
    28: .same(proto: "three_marker_dist"),
    29: .same(proto: "SpineBend"),
    30: .same(proto: "FootTrajectory"),
  ]
}

extension Observations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Observations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lidars"),
    2: .same(proto: "poses"),
    3: .same(proto: "bboxes"),
    4: .same(proto: "segmentations"),
    5: .same(proto: "date"),
    6: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lidars) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.poses) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.bboxes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.segmentations) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lidars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lidars, fieldNumber: 1)
    }
    if !self.poses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poses, fieldNumber: 2)
    }
    if !self.bboxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bboxes, fieldNumber: 3)
    }
    if !self.segmentations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segmentations, fieldNumber: 4)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Observations, rhs: Observations) -> Bool {
    if lhs.lidars != rhs.lidars {return false}
    if lhs.poses != rhs.poses {return false}
    if lhs.bboxes != rhs.bboxes {return false}
    if lhs.segmentations != rhs.segmentations {return false}
    if lhs.date != rhs.date {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BBoxSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BBoxSequence"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BBoxSequence, rhs: BBoxSequence) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SegmentationSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SegmentationSequence"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SegmentationSequence, rhs: SegmentationSequence) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepthSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DepthSequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frames"),
    2: .same(proto: "camera"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.frames) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._camera) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.frames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frames, fieldNumber: 1)
    }
    try { if let v = self._camera {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepthSequence, rhs: DepthSequence) -> Bool {
    if lhs.frames != rhs.frames {return false}
    if lhs._camera != rhs._camera {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepthMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DepthMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "map"),
    4: .standard(proto: "is_row_wise"),
    5: .standard(proto: "frame_id"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "unit"),
    8: .same(proto: "scale"),
    9: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.map) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isRowWise) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.frameID) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if !self.map.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.map, fieldNumber: 3)
    }
    if self.isRowWise != false {
      try visitor.visitSingularBoolField(value: self.isRowWise, fieldNumber: 4)
    }
    if self.frameID != 0 {
      try visitor.visitSingularInt32Field(value: self.frameID, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularFloatField(value: self.timestamp, fieldNumber: 6)
    }
    if self.unit != .mm {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 7)
    }
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 8)
    }
    if !self.confidence.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.confidence, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepthMap, rhs: DepthMap) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.map != rhs.map {return false}
    if lhs.isRowWise != rhs.isRowWise {return false}
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepthMap.Units: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "mm"),
    1: .same(proto: "cm"),
    2: .same(proto: "meters"),
    3: .same(proto: "voxel"),
    4: .same(proto: "int8"),
    5: .same(proto: "int16"),
    6: .same(proto: "int32"),
  ]
}

extension DepthMap.row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DepthMap.protoMessageName + ".row"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.row) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.row.isEmpty {
      try visitor.visitPackedFloatField(value: self.row, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepthMap.row, rhs: DepthMap.row) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Pose"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pose"),
    2: .standard(proto: "frame_id"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "pose_type"),
    5: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pose) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.frameID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.poseType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pose.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pose, fieldNumber: 1)
    }
    if self.frameID != 0 {
      try visitor.visitSingularInt32Field(value: self.frameID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularFloatField(value: self.timestamp, fieldNumber: 3)
    }
    if self.poseType != .none {
      try visitor.visitSingularEnumField(value: self.poseType, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pose, rhs: Pose) -> Bool {
    if lhs.pose != rhs.pose {return false}
    if lhs.frameID != rhs.frameID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.poseType != rhs.poseType {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PoseSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PoseSequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frames"),
    2: .same(proto: "algorithm"),
    3: .same(proto: "source"),
    4: .same(proto: "camera"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.frames) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.algorithm) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._camera) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.frames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frames, fieldNumber: 1)
    }
    if self.algorithm != .none {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    try { if let v = self._camera {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PoseSequence, rhs: PoseSequence) -> Bool {
    if lhs.frames != rhs.frames {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.source != rhs.source {return false}
    if lhs._camera != rhs._camera {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Camera: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Camera"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "intrinsics"),
    3: .same(proto: "extrinsics"),
    4: .standard(proto: "is_virtual"),
    5: .same(proto: "odometry"),
    6: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _intrinsics: Camera.Intrinsics?
    var _extrinsics: CoordinateSystem?
    var _isVirtual: Bool = false
    var _odometry: OdometrySequence?
    var _type: Camera.Types = .rgb

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _intrinsics = source._intrinsics
      _extrinsics = source._extrinsics
      _isVirtual = source._isVirtual
      _odometry = source._odometry
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._intrinsics) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._extrinsics) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isVirtual) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._odometry) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._intrinsics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._extrinsics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._isVirtual != false {
        try visitor.visitSingularBoolField(value: _storage._isVirtual, fieldNumber: 4)
      }
      try { if let v = _storage._odometry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._type != .rgb {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Camera, rhs: Camera) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._intrinsics != rhs_storage._intrinsics {return false}
        if _storage._extrinsics != rhs_storage._extrinsics {return false}
        if _storage._isVirtual != rhs_storage._isVirtual {return false}
        if _storage._odometry != rhs_storage._odometry {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Camera.Types: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RGB"),
    1: .same(proto: "LIDAR"),
    3: .same(proto: "RGBD"),
  ]
}

extension Camera.Intrinsics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Camera.protoMessageName + ".Intrinsics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resolution"),
    2: .standard(proto: "pixel_size"),
    3: .same(proto: "distortion"),
    4: .standard(proto: "focal_length_x"),
    5: .standard(proto: "focal_length_y"),
    6: .standard(proto: "center_point_x"),
    7: .standard(proto: "center_point_y"),
    8: .same(proto: "skew"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resolution) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pixelSize) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.distortion) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.focalLengthX) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.focalLengthY) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.centerPointX) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.centerPointY) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.skew) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pixelSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.distortion.isEmpty {
      try visitor.visitPackedFloatField(value: self.distortion, fieldNumber: 3)
    }
    if self.focalLengthX != 0 {
      try visitor.visitSingularFloatField(value: self.focalLengthX, fieldNumber: 4)
    }
    if self.focalLengthY != 0 {
      try visitor.visitSingularFloatField(value: self.focalLengthY, fieldNumber: 5)
    }
    if self.centerPointX != 0 {
      try visitor.visitSingularFloatField(value: self.centerPointX, fieldNumber: 6)
    }
    if self.centerPointY != 0 {
      try visitor.visitSingularFloatField(value: self.centerPointY, fieldNumber: 7)
    }
    if self.skew != 0 {
      try visitor.visitSingularFloatField(value: self.skew, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Camera.Intrinsics, rhs: Camera.Intrinsics) -> Bool {
    if lhs._resolution != rhs._resolution {return false}
    if lhs._pixelSize != rhs._pixelSize {return false}
    if lhs.distortion != rhs.distortion {return false}
    if lhs.focalLengthX != rhs.focalLengthX {return false}
    if lhs.focalLengthY != rhs.focalLengthY {return false}
    if lhs.centerPointX != rhs.centerPointX {return false}
    if lhs.centerPointY != rhs.centerPointY {return false}
    if lhs.skew != rhs.skew {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Camera.Intrinsics.Unit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MM"),
  ]
}

extension Camera.Intrinsics.Resolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Camera.Intrinsics.protoMessageName + ".Resolution"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Camera.Intrinsics.Resolution, rhs: Camera.Intrinsics.Resolution) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Camera.Intrinsics.Size: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Camera.Intrinsics.protoMessageName + ".Size"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "unit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 2)
    }
    if self.unit != .mm {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Camera.Intrinsics.Size, rhs: Camera.Intrinsics.Size) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMU: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IMU"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "acc_x"),
    2: .standard(proto: "acc_y"),
    3: .standard(proto: "acc_z"),
    4: .standard(proto: "gyr_x"),
    5: .standard(proto: "gyr_y"),
    6: .standard(proto: "gyr_z"),
    7: .standard(proto: "mag_x"),
    8: .standard(proto: "mag_y"),
    9: .standard(proto: "mag_z"),
    10: .standard(proto: "grv_x"),
    11: .standard(proto: "grv_y"),
    12: .standard(proto: "grv_z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.accX) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.accY) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.accZ) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.gyrX) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.gyrY) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.gyrZ) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.magX) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.magY) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.magZ) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.grvX) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.grvY) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.grvZ) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accX != 0 {
      try visitor.visitSingularFloatField(value: self.accX, fieldNumber: 1)
    }
    if self.accY != 0 {
      try visitor.visitSingularFloatField(value: self.accY, fieldNumber: 2)
    }
    if self.accZ != 0 {
      try visitor.visitSingularFloatField(value: self.accZ, fieldNumber: 3)
    }
    if self.gyrX != 0 {
      try visitor.visitSingularFloatField(value: self.gyrX, fieldNumber: 4)
    }
    if self.gyrY != 0 {
      try visitor.visitSingularFloatField(value: self.gyrY, fieldNumber: 5)
    }
    if self.gyrZ != 0 {
      try visitor.visitSingularFloatField(value: self.gyrZ, fieldNumber: 6)
    }
    if self.magX != 0 {
      try visitor.visitSingularFloatField(value: self.magX, fieldNumber: 7)
    }
    if self.magY != 0 {
      try visitor.visitSingularFloatField(value: self.magY, fieldNumber: 8)
    }
    if self.magZ != 0 {
      try visitor.visitSingularFloatField(value: self.magZ, fieldNumber: 9)
    }
    if self.grvX != 0 {
      try visitor.visitSingularFloatField(value: self.grvX, fieldNumber: 10)
    }
    if self.grvY != 0 {
      try visitor.visitSingularFloatField(value: self.grvY, fieldNumber: 11)
    }
    if self.grvZ != 0 {
      try visitor.visitSingularFloatField(value: self.grvZ, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMU, rhs: IMU) -> Bool {
    if lhs.accX != rhs.accX {return false}
    if lhs.accY != rhs.accY {return false}
    if lhs.accZ != rhs.accZ {return false}
    if lhs.gyrX != rhs.gyrX {return false}
    if lhs.gyrY != rhs.gyrY {return false}
    if lhs.gyrZ != rhs.gyrZ {return false}
    if lhs.magX != rhs.magX {return false}
    if lhs.magY != rhs.magY {return false}
    if lhs.magZ != rhs.magZ {return false}
    if lhs.grvX != rhs.grvX {return false}
    if lhs.grvY != rhs.grvY {return false}
    if lhs.grvZ != rhs.grvZ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OdometryInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OdometryInstance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "imu"),
    3: .standard(proto: "coordinate_system"),
  ]

  fileprivate class _StorageClass {
    var _timestamp: Float = 0
    var _imu: IMU?
    var _coordinateSystem: CoordinateSystem?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamp = source._timestamp
      _imu = source._imu
      _coordinateSystem = source._coordinateSystem
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._timestamp) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._imu) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._coordinateSystem) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._timestamp != 0 {
        try visitor.visitSingularFloatField(value: _storage._timestamp, fieldNumber: 1)
      }
      try { if let v = _storage._imu {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._coordinateSystem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OdometryInstance, rhs: OdometryInstance) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._imu != rhs_storage._imu {return false}
        if _storage._coordinateSystem != rhs_storage._coordinateSystem {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OdometrySequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OdometrySequence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trajectory"),
    2: .same(proto: "source"),
    3: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.trajectory) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trajectory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trajectory, fieldNumber: 1)
    }
    if self.source != .slam {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OdometrySequence, rhs: OdometrySequence) -> Bool {
    if lhs.trajectory != rhs.trajectory {return false}
    if lhs.source != rhs.source {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OdometrySequence.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLAM"),
  ]
}

extension CoordinateSystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoordinateSystem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transform"),
    2: .standard(proto: "is_origin"),
    3: .standard(proto: "is_right_hand"),
    4: .standard(proto: "up_axis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._transform) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isOrigin) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRightHand) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.upAxis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transform {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isOrigin != false {
      try visitor.visitSingularBoolField(value: self.isOrigin, fieldNumber: 2)
    }
    if self.isRightHand != false {
      try visitor.visitSingularBoolField(value: self.isRightHand, fieldNumber: 3)
    }
    if self.upAxis != .x {
      try visitor.visitSingularEnumField(value: self.upAxis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoordinateSystem, rhs: CoordinateSystem) -> Bool {
    if lhs._transform != rhs._transform {return false}
    if lhs.isOrigin != rhs.isOrigin {return false}
    if lhs.isRightHand != rhs.isRightHand {return false}
    if lhs.upAxis != rhs.upAxis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoordinateSystem.Axis: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "X"),
    1: .same(proto: "Y"),
    2: .same(proto: "Z"),
    3: .same(proto: "minusX"),
    4: .same(proto: "minusY"),
    5: .same(proto: "minusZ"),
  ]
}

extension Keypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Keypoint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "joint"),
    2: .same(proto: "point"),
    3: .same(proto: "confidence"),
    4: .standard(proto: "to_joint"),
    5: .standard(proto: "contact_confidence"),
    6: .standard(proto: "point_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.joint) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.point) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.toJoint) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.contactConfidence) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.pointType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.joint != .nose {
      try visitor.visitSingularEnumField(value: self.joint, fieldNumber: 1)
    }
    if !self.point.isEmpty {
      try visitor.visitPackedFloatField(value: self.point, fieldNumber: 2)
    }
    if self.confidence != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 3)
    }
    if self.toJoint != .nose {
      try visitor.visitSingularEnumField(value: self.toJoint, fieldNumber: 4)
    }
    if self.contactConfidence != 0 {
      try visitor.visitSingularFloatField(value: self.contactConfidence, fieldNumber: 5)
    }
    if self.pointType != .xy {
      try visitor.visitSingularEnumField(value: self.pointType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Keypoint, rhs: Keypoint) -> Bool {
    if lhs.joint != rhs.joint {return false}
    if lhs.point != rhs.point {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.toJoint != rhs.toJoint {return false}
    if lhs.contactConfidence != rhs.contactConfidence {return false}
    if lhs.pointType != rhs.pointType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Translation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Translation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
    3: .same(proto: "z"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.z) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    if self.z != 0 {
      try visitor.visitSingularFloatField(value: self.z, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Translation, rhs: Translation) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.z != rhs.z {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Orientation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Orientation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rotationType"),
    2: .same(proto: "rotationValues"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rotationType) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.rotationValues) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rotationType != .quaternion {
      try visitor.visitSingularEnumField(value: self.rotationType, fieldNumber: 1)
    }
    if !self.rotationValues.isEmpty {
      try visitor.visitPackedFloatField(value: self.rotationValues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Orientation, rhs: Orientation) -> Bool {
    if lhs.rotationType != rhs.rotationType {return false}
    if lhs.rotationValues != rhs.rotationValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Orientation.RotationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUATERNION"),
    1: .same(proto: "MATRIX"),
    2: .same(proto: "EULER_XYZ"),
    3: .same(proto: "EULER_XZY"),
    4: .same(proto: "EULER_YXZ"),
    5: .same(proto: "EULER_YZX"),
    6: .same(proto: "EULER_ZXY"),
    7: .same(proto: "EULER_ZYX"),
    8: .same(proto: "EULER_XY"),
    9: .same(proto: "EULER_YX"),
    10: .same(proto: "EULER_XZ"),
    11: .same(proto: "EULER_ZX"),
    12: .same(proto: "EULER_YZ"),
    13: .same(proto: "EULER_ZY"),
    14: .same(proto: "EULER_X"),
    15: .same(proto: "EULER_Y"),
    16: .same(proto: "EULER_Z"),
  ]
}

extension Transform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Transform"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translation"),
    2: .same(proto: "orientation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._translation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._orientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._translation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._orientation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Transform, rhs: Transform) -> Bool {
    if lhs._translation != rhs._translation {return false}
    if lhs._orientation != rhs._orientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
